#
#   MIT License
#   
#   Copyright (c) 2024, Mattias Aabmets
#   
#   The contents of this file are subject to the terms and conditions defined in the License.
#   You may not use, modify, or distribute this file except in compliance with the License.
#   
#   SPDX-License-Identifier: MIT
#

import re
import string
import platform
import importlib
from cffi import FFI
from abc import ABC, abstractmethod
from types import ModuleType
from typing import Literal, Type
from functools import lru_cache
from quantcrypt.internal import utils, errors, constants as const


__all__ = ["BasePQAParamSizes", "BasePQAlgorithm"]


class BasePQAParamSizes:
	def __init__(self, lib: ModuleType, cdef_name: str):
		self.sk_size = getattr(lib, f"{cdef_name}_CRYPTO_SECRETKEYBYTES")
		self.pk_size = getattr(lib, f"{cdef_name}_CRYPTO_PUBLICKEYBYTES")


class BasePQAlgorithm(ABC):
	_lib: ModuleType
	variant: const.PQAVariant

	@property
	def spec(self) -> const.AlgoSpec:
		return self._get_spec()

	@classmethod
	def _get_spec(cls) -> const.AlgoSpec:
		for spec in const.SupportedAlgos:
			if spec.class_name == cls.__name__:
				return spec
		raise errors.PQAUnsupportedClassError(cls.__name__)

	@abstractmethod
	def keygen(self) -> tuple[bytes, bytes]: ...

	@property
	@abstractmethod
	def param_sizes(self) -> BasePQAParamSizes: ...

	@property
	def _cdef_name(self) -> str:
		return self.spec.cdef_name(self.variant)

	@property
	def _auto_select_variant(self) -> const.PQAVariant:
		opsys = platform.machine().lower()
		if opsys in const.ARMArches:
			return const.PQAVariant.ARM
		elif opsys in const.AMDArches:
			return const.PQAVariant.OPT
		return const.PQAVariant.REF

	@lru_cache
	def _import(self, variant: const.PQAVariant) -> ModuleType:
		module_name = self.spec.module_name(variant)
		module_path = f"quantcrypt.internal.bin.{module_name}"
		return importlib.import_module(module_path).lib

	def __init__(self, variant: const.PQAVariant | None = None) -> None:
		try:
			self.variant = variant or self._auto_select_variant
			self._lib = self._import(self.variant)
		except ModuleNotFoundError:
			if self.variant != const.PQAVariant.REF:
				try:
					self.variant = const.PQAVariant.REF
					self._lib = self._import(const.PQAVariant.REF)
					return
				except ModuleNotFoundError:  # pragma: no cover
					pass
			raise errors.MissingBinariesError(self.variant)

	def _algo_name(self) -> str:
		return self.__class__.__name__.replace('_', '').upper()

	def _keygen(
			self,
			algo_type: Literal["kem", "sign"],
			error_cls: Type[errors.PQAError]
		) -> tuple[bytes, bytes]:
		ffi, params = FFI(), self.param_sizes
		public_key = ffi.new(f"uint8_t [{params.pk_size}]")
		secret_key = ffi.new(f"uint8_t [{params.sk_size}]")

		func_name = f"_crypto_{algo_type}_keypair"
		func = getattr(self._lib, self._cdef_name + func_name)
		if func(public_key, secret_key) != 0:  # pragma: no cover
			raise error_cls

		pk = ffi.buffer(public_key, params.pk_size)
		sk = ffi.buffer(secret_key, params.sk_size)
		return bytes(pk), bytes(sk)

	@utils.input_validator()
	def armor(self, key_bytes: bytes) -> str:
		"""
		:param key_bytes: The key bytes that were generated by a PQA class,
			that are going to be armored into a base64-encoded ASCII text.
		:return: ASCII armored key string
		:raises - pydantic.ValidationError: On invalid input.
		:raises - errors.PQAKeyArmorError: If armoring fails for any reason.
		"""
		params = self.param_sizes
		match len(key_bytes):
			case params.sk_size:
				key_type = "SECRET"
			case params.pk_size:
				key_type = "PUBLIC"
			case _:
				raise errors.PQAKeyArmorError("armor")
		key_str = utils.b64(key_bytes)
		max_line_length = 64
		lines = [
			key_str[i:i + max_line_length]
			for i in range(0, len(key_str), max_line_length)
		]
		algo_name = self._algo_name()
		header = f"-----BEGIN {algo_name} {key_type} KEY-----\n"
		footer = f"\n-----END {algo_name} {key_type} KEY-----"
		return header + '\n'.join(lines) + footer

	@utils.input_validator()
	def dearmor(self, armored_key: str) -> bytes:
		"""
		:param armored_key: An ASCII armored PQA key, armored by
			the same PQA class that is being used to dearmor the key.
		:return: Bytes of the de-armored key
		:raises - pydantic.ValidationError: On invalid input.
		:raises - errors.PQAKeyArmorError: If dearmoring fails for any reason.
		"""
		dearmor_error = errors.PQAKeyArmorError("dearmor")
		algo_name = self._algo_name()
		key_data: str = ''

		for key_type in ["PUBLIC", "SECRET"]:
			header_pattern = rf"^-----BEGIN {algo_name} {key_type} KEY-----\n"
			footer_pattern = rf"\n-----END {algo_name} {key_type} KEY-----$"
			full_pattern = header_pattern + r"(.+)" + footer_pattern
			if match := re.match(full_pattern, armored_key, re.DOTALL):
				key_data = match.group(1) or ''
				for char in string.whitespace:
					key_data = key_data.replace(char, '')
				break

		if not key_data:
			raise dearmor_error

		try:
			key_bytes = utils.b64(key_data)
		except errors.InvalidArgsError:
			raise dearmor_error

		expected_size = dict(
			PUBLIC=self.param_sizes.pk_size,
			SECRET=self.param_sizes.sk_size
		)[key_type]
		if len(key_bytes) != expected_size:
			raise dearmor_error

		return key_bytes
